# EasyChair (Classic Edition)
本仓库提供的应用程序是功能强大的模拟联合国会议主持软件 EasyChair 的早期版本，首个版本创建于 2012 年度末。它基于罗伯特议事规则设计，帮助您主持、管理会场并推动会议进程。

在被后续版本的第三代 EasyChair 和 Console Lite 替代前，EasyChair Classic 在北京地区模拟联合国会议中的“市场占有率”约为 99%。

## 请注意
**本程序已停止维护，并已被[第三代 EasyChair](https://github.com/CRH380B-6216L/easychair3)取代。**

由于存在广泛的关于“新的 EasyChair 不稳定”和“Console Lite 不好用”的评价，为了给大家提供一个“好用又稳定”的会议主持软件，我找回了初代 EasyChair 的程序和源代码，并仅以此目的以“EasyChair Classic”的名义发布。

**[请支持并使用功能全面的第三代 EasyChair](https://github.com/CRH380B-6216L/easychair3)**

**[会写 C++？来这里一起创造为跨平台设计的全新 EasyChair（的核心功能库）！](https://github.com/CRH380B-6216L/easychair-core)**

## 特性
- **功能全面**：对罗伯特议事规则的所有流程要素提供完整支持
- **运行稳定**：完全地面向过程（Procedure Oriented）编写，具有极强稳定性
- **音效提示**：当计时器剩余时间很少或耗尽时，EasyChair 会播放音效提醒 
- **极致轻量化**：程序文件小于 1.44 MB，可以存储于 3.5 英寸软盘中方便携带

## 系统需求
您必须在 Windows 11/10/8.1/8/7/Vista/XP (SP3) 操作系统下使用本软件。

对 Windows 8 以下的用户，您需要安装 [.NET Framework 4.0]("https://learn.microsoft.com/zh-cn/previous-versions/dotnet/netframework-4.0/5a4x27ek(v=vs.100)") 以确保本软件可以在您的计算机上运行。 

## 下载安装
请进入本项目的 [Releases 页面](https://github.com/CRH380B-6216L/easychair-classic/releases)下载最新版本。解包即用。

使用本软件前，您**不需要**向任何人申请或申报。

## 使用 Easychair
使用说明请查阅[“EasyChair.pdf”文件](https://github.com/CRH380B-6216L/easychair-classic/blob/master/EasyChair.pdf)。

## 模联会议软件发展史
2012 年以前，模拟联合国的发展尚不广泛，会议软件也极为原始。当时的会议软件使用 Visual Basic 6.0 制作，其作者不详，外观是蓝色的背景板中有巨大的文本框，右上角是计时器，下面还是右面我记不清了有一排按钮，点了之后就可以将会议指令的定型文添加到文本框里，发言列表则直接在文本框里手输。至 2012 年 10 月，我被入选为 BJMUNC 2013 的主席团成员。在会议准备阶段，我不喑学术之道，却想着制作一款“更专业、更便捷”的会议主持软件。于是 EasyChair 就这样诞生了。

得益于我在 2005 年于中国儿童中心学习的电脑编程经验，我得以自主编写这一程序。我抛弃了 Visual Basic 6.0，理由是 VB 6.0 的控件在任何操作系统下其形态都停留在 Windows 98 的风格，我嫌他土掉渣，所以应用了更新锐的 Visual Basic 2010 版本。

在制作过程中我时不时地向“人人网”上上传原型截图，然后被当时的中文学术总监王苏煦发现了，他同时也把我引荐到了 BJMUN 技术部。随着 BJMUNC 2013 的成功举办，EasyChair也“正式出道”，并且一经出道就“火遍大江南北”。因为很好用，所以很流行。因为自己既是开发者也是使用者，所以在开发中自然而然地考虑使用的感受。不过当时我所收集到的最多的意见是“开发 Mac 版本”，但！是！我！没！有！苹！果！机！啊！，所以这个请求就一直搁置，而给出的替代建议是“主席团里面总得有个用 Windows 电脑的人吧”😂

在 2013 至 2014 年度，我对 EasyChair 进行了一次整体的迭代。因为功能区过多地占用窗口，可以用于显示信息的空间太少了。然后同时我还发现 .NET Framework 程序如果把主窗体的边框设置成无、窗口形态设置成默认最大化，那么程序可以自动全屏！也就是说如果分辨率更高，那么可以显示的内容也就更多。

第二代 EasyChair 还没有发在 GitHub 上，不过可以描述一下：它的样子是白色为主和深青色的侧边栏，下面有一排六个一级菜单，点开之后在右面就有对应操作的卷展栏。尤其是国家列表和有主持核心磋商的控制台非常占用空间，在第二代就被折叠了，只在使用的时候显示，这样就释放了很多的空间。还有就是新界面，我硬是在 Win32 框架下把控件一个一个改成平面形式，工作量也挺大。

第二代 EasyChair 由于功能更全面，很快就替代了第一代成为了主流的会议软件。在编写的时候我发现了 VB .net 面向对象语言风格的奥秘，在第二代 EasyChair 中开始应用。面向对象的 VB .net 让我有了在 Fontys ICT 第一年的 C# 课程里拿下了三个 9 分和一个 10 分满分的底气，但也是 EasyChair 代码屎山化的开端。

在 2014 至 2015 年度，我还是不太满足，对 EasyChair 进行了又一次的整体迭代，也就是现在的[第三代 EasyChair](https://github.com/CRH380B-6216L/easychair3)。第三代最重要的更新是借助 Windows 系统的投影仪模式实现操作和显示的上下分离。操作部分引用了一个叫做 [DockPanelSuite](https://github.com/dockpanelsuite/dockpanelsuite) 的框架，但因为是 C# 编写的所以整合进 VB 程序的时候有点费劲，不过这样就实现了像 Visual Studio 一样把功能窗口拖拽和固定到任何地方。显示部分制作了一个 WPF 用户控件，把屏幕做成了一个带背景图片的漂亮的 XAML 页面，结合 WPF x Win32 的互操作性，实现了两者之间的实时联动。

其实早在制作第二代 EasyChair 的时候就考虑过显示与操作上下分离的模式，不过当时有一家竞品厂商 MUNCS 的负责人提出“该如何实现显示内容的实时更新”这个问题，我当时还想不出如何实现，就搁置到了第三代。另外他还提出了“EasyChair 这个名字有人在用”这件事，然后就开始想改名的事，想着想着觉得这个软件的操作部分就像个操作台（Console）一样，“Console”的名字就是这样来的。

*关于竞品 MUNCS，他们也是和我的 EasyChair 差不多时期创立的，软件质量来说其实不输 EasyChair，而且他们有一整个技术团队。MUNCS 在全国范围都有用户，除了被 EasyChair 强势占领的北京地区，在他们的用户报告中是炸眼的灰色。但是我嗤之以鼻的是 MUNCS 的“授权发放”制度，也就是必须要获得使用许可——虽然是免费的；但是这样一来开发者就可以以自己的意志任意地拒绝授权。（比如不喜欢某个会，然后拒绝他使用我的产品）但是对我来说这是无法接受的，制作 EasyChair 软件就是为了造福模拟联合国活动，应该向真正的联合国的宗旨一样，用开放和包容的姿态给所有人提供服务。所以我开放 EasyChair 的使用时从来没有限制条件，直到现在或者以后任何时候都不需要向任何人申请或申报。永远不会。*

第三代 EasyChair 除了显示与操作上下分离以外，另外有这些有特点的更新：
- 可以将会议文件的文本作为附件显示在投影屏幕上。最开始找到的解决方案也很奇特，大概是从后台打开一个 Word，然后把这个文件另存为 HTML 格式。在 WPF 屏幕控件设置一个浏览器，显示被另存为的 HTML 文件。这个解决方案过于奇葩，似乎从没在本机以外的环境成功过。后来是记不起来什么时候换成了 [Mammoth](https://github.com/mwilliamson/dotnet-mammoth) 库，直接把 Word 格式转换成 HTML。
- 创造了一个“危机编写器”，可以把危机的标题和内容填进去，然后直接投送到屏幕控件的浏览器上。众所周知 HTML 就是 XML 😂，我用 XMLWriter 类把危机的内容写成 HTML 格式，内联 CSS、标题大字、横线、正文也稍微大一点。《代表的噩梦来啦！》15 年 2 月完成了危机编写器，然后在朋友圈里造成了很大的反响。
- 因为课业的缘故接触了 WCF 框架，这是一种 Windows + ASP 技术构架下服务端与客户端相互通信的功能。发现这个东西对危机联动来说刚好能用到，而主席控制侧是客户端，所以第三代 EasyChair 最早的名字是 Console Client，对应的服务端叫 Console Host，不过从来没有正式制作过，只是制作出了一个能够向客户端发送危机的原型机。

但遗憾的是，由于从第二代 EasyChair 积累下来的屎山以及在第三代当时还叫 Console Client 的软件加了太多的功能的缘故，导致程序在运行过程中会逐渐积累不稳定，更多人更愿意停留在第二代 EasyChair 中，Console Client 的市场表现并不是太影响。最后逆输出到我作为开发者这一侧就是更新变得逐渐消极直至停滞。当时的工作重心转移到了一个叫做 Console iT 的在线报名管理系统上，对会议软件这一侧基本上已经无心关注。Console iT 的主要创作者，那一届的技术总监[刘晓义](https://github.com/CircuitCoder)，在制作报名管理系统的同时制作出了 [Console Lite](https://github.com/CircuitCoder/Console-Lite) 会议软件。

Console Lite 解决了长久以来 Macintosh 操作系统没有合适的会议软件的尴尬局面。它基于 [Electron](https://electronjs.org/) 开发，天然支持全平台使用，由于是使用 JavaScript 语言编写，理论上来说是可以部署成为在线应用的。Console Lite 的最大特点是它的弱规则性，即不遵循某种特定的议事规则，只是通过创建和使用“发言列表”和“计时器”实现会议进程的控制。这一点很符合面向对象设计的原理：把“发言列表”和“计时器”看成一个类，每开启一个动议都创建一个实例（二者之一），不同的实例之间互不干涉。如果想要做成 EasyChair 一样严格基于规则流程，那么主发言名单、有主持核心磋商、自由磋商等规则中的流程都可以制作成“发言列表”或“计时器”的继承类，各自添加一些独特的构造函数、属性、方法和事件，可扩展性强、更易维护。

但是 Console Lite 有一个最大的问题就是严重占用存储空间，其解压缩之后大小高达 279 MB。这似乎是 Electron 应用程序的通病：另一些基于 Electron 的程序比如 [Clash for Windows](https://github.com/Fndroid/clash_for_windows_pkg) 占用空间 250 MB，[赛马娘同人文阅读器](https://github.com/umalib/UmaLibDesktop)占用空间 289 MB。对照组：[EasyChair 3 最近的一个 Release](https://github.com/CRH380B-6216L/easychair3/releases) 解包后仅占用 8.73 MB。两相比较，从占用空间上来说 Console Lite 一点也不“lite”，而是“massive”。（所以明白为什么 Electron 程序都喜欢用 7Z 格式发布了吧）但是这又怎样呢，人家 Console Lite 能全平台，比 EasyChair 稳定，对于电脑小白来说，占用空间，多大点事？从这以后，Console Lite 便代替 EasyChair 成为了更流行的模拟联合国会议软件。

其实疏于维护也是一方面，到 2017 年度我一直在折腾报名管理系统；后来报名管理系统遭受了严重的失败，导致我直接丢掉键盘和终端，转行研究市域（郊）铁路领域了。直到现在，再也没有一个编程高手可以制作出一个完善又好用的会议软件或者报名管理系统，而报名管理这边 BJMUN 也是全面倒向“造不如买、买不如租”，直接使用第三方提供的拼装式程序完成报名管理流程。后来也忘了是什么时候出于什么原因，我把当时的 Console Client [改回了 EasyChair 原名，并且开源到 Github 上](https://github.com/CRH380B-6216L/easychair3)。

今年（2023）以来逐渐听到了一些“Console Lite 不好用”的评价，然后会场里主席突然问“谁会用 Console Lite 啊”，每次我都回答“请在 GitHub 上搜索 EasyChair 3，大家都来看一看”。这次我把最早的 EasyChair Classic 也发不出来，希望给大家多一个选择吧。

EasyChair 的未来——虽然 Console Lite 又占空间又不好用，但是我承认它的编写思路还是更优的。那么 EasyChair 我也希望按照这个思路彻底重构，不过就不要用 JavaScript 和 Electron 了，Election 并不是跨平台的必须，传统的 C++ 也可以跨平台编译，而且程序文件可以十分紧凑；使用 [wxWidgets](https://www.wxwidgets.org/) 构建用户界面，保证操作统一的同时又能与不同操作系统的界面风格（Windows/Mac/Linux）保持一致。只是我对 C++ 的编写还是很苦手，希望什么时候能出一个编程大神来一起填坑吧。

## 声明
- 本产品基于 MIT 协议开源。